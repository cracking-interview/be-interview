# ☕️ Java

- 1. Python vs Java vs Kotlin
    - Python
        - 통상적 인터프리터 언어이지만 내부에 JIT이라는 컴파일러가 내장되어 있음. 하지만 파이썬을 이것으로 구분하는 것은 잘못된 접근일 수 있음.
        - 데이터 타입이 동적으로 입력됨에 따라 변수형의 자료형을 따로 선언하지 않아도 됨.
    - Java
        - JVM으로 실행돼서 OS에 관계없이 동작한다.
        - 정적 데이터 타입 명시가 필요하다.
        - 100% 객체 지향언어로, 캡슐화, 상속, 다형성을 지원한다.
    - Kotlin
        - 자바보다 null 안전성(safety)이 좋다.
        - data class를 이용해 자바의 보일러 플레이트 코드를 줄일 수 있다.
- 2. 자바의 장단점
    - 장점
        - 운영체제에 독립적(JVM)
        - 동적 로딩을 지원
            - 애플리케이션이 실행될 때 모든 객체가 생성되지 않고, 각 객체가 필요한 시점에 클래스를 동적 로딩해서 생성된다.
    - 단점
        - JVM에 의해 기계어로 번역되고 실행되는 과정을 거치기 때문에 조금 느리다.
- 3. OOP(객체지향)의 특징
    1. 캡슐화
        - 정보 은닉 : 필요 없는 정보는 외부에서 접근하지 못하도록 제한
        - 높은 응집도, 낮은 결합도로 유연함과 유지보수성 증가
    2. 추상화
        - 공통적인 특징을 파악해 하나의 집합으로 다루는 것
    3. 상속
        - 기존 상위 클래스에 근거해 새로운 클래스와 행위를 정의
    4. 다형성
        - 오버로딩(overloading) : 메소드의 이름은 같지만, 파라미터의 타입 또는 개수를 다르게 하는 것.
        - 오버라이딩(overriding) : **재정의!** 하위 클래스에서 상위 클래스의 메소드를 재정의 하여 사용하는 것. 이를 이용하면 코드의 재사용성이 높아짐.
- 4. OOP SOLID 원칙
    - S : 단일 책임 원칙(Single Responsible Principle)
        - 객체는 단 하나의 책임만을 가져야한다.
        - 어떤 변화에 의해 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다.
    - O : 개방 폐쇄 원칙(Open Closed Principle)
        - 기존 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계되어야 한다.
    - L : 리스코프 치환 원칙
        - 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야한다.
    - I : 인터페이스 분리 원칙
        - 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
        - 인터페이스가 명확해지고, 대체 가능성이 높아진다.
    - D : 의존관계 역전 원칙 (Dependency Inversion Principle)
        - 의존 관계를 맺을 때 변화하기 쉬운 것 또는 자주 변화하는 것보다는 변화하기 어려운 것, 거의 변화가 없는 것에 의존하라는 것이다.
        - 쉽게 이야기하면, 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻
- 5. 객체 지향 프로그래밍 vs 절차 지향 프로그래밍
    - 절차 지향 프로그래밍
        - 실행하고자 하는 절차를 정하고, 순차적으로 프로그래밍 하는 방식으로 빠르다.
        - 엄격하게 순서가 정해져 있기에 비효율적이고 유지보수가 어렵다.
        - 목적을 달성하기 위한 일의 흐름에 중점을 둔다.
    - 객체 지향 프로그래밍
        - 구현해야할 객체들 사이의 상호작용을 프로그래밍하는 방식으로 상속, 다형성, 추상화, 캡슐화를 통해 결합도를 낮추고 응집도를 높일 수 있으며 코드의 재사용성도 높일 수 있다.
- 6. JVM의 구성 요소
    - 자바 프로그램을 실행하는 역할
        - 컴파일러를 통해 바이트 코드로 변환된 파일을 JVM에 로딩하여 실행
    - Class Loader : JVM 내(Runtime Data Area)로 Class 파일을 로드하고 링크
    - Execution Engine : 메모리(Runtime Data Area)에 적재된 클래스들을 기계어로 변경해 실행
    - Garbage Collector : 힙 메모리에서 참조되지 않는 개체들 제거
    - Runtime Data Area : 자바 프로그램을 실행할 때, 데이터를 저장
- 7. JVM 실행과정
    1. JVM은 OS로부터 메모리(Runtime Data Area)를 할당 받음
    2. 컴파일러(javac)가 소스코드(.java)를 읽어 바이트 코드(.class)로 변환
    3. Class Loader를 통해 Class파일을 JVM내 Runtime Data Area로 로딩
    4. 로딩된 Class 파일을 Execution Engine을 통해 해석 및 실행
- 8. JVM 메모리(Runtime Data Area) 구조
    
    <img width="660" alt="image" src="https://user-images.githubusercontent.com/84627144/177464955-0f059f83-1268-4954-9500-b1905d730036.png">
    
    - 메서드(static) 영역
        - 클래스가 사용되면 해당 클래스의 파일(.class)을 읽어들여, 클래스에 대한 정보(바이트 코드)를 메서드 영역에 저장
        - 클래스와 인터페이스, 메서드, 필드, static 변수, final 변수 등이 저장되는 영역입니다.
    - JVM 스택 영역
        - 스레드마다 존재하여 스레드가 시작할 때마다 할당
        - 지역변수, 매개변수, 연산 중 발생하는 임시 데이터 저장
        - 메서드 호출 시마다 개별적 스택 생성
    - JVM 힙 영역
        - 런타임 시 동적으로 할당하여 사용하는 영역
        - new 연산자로 생성된 객체와 배열 저장
        - 참조가 없는 객체는 GC(가비지 컬렉터)의 대상
    - pc register
        - 쓰레드가 현재 실행할 스택 프레임의 주소를 저장
    - Native Method Stack
        - C/C++ 등의 Low level 코드를 실행하는 스택
- 9. 가비지 컬렉터
    - 사용하지 않는 메모리(unreferenced memory)를 지워 메모리를 확보하는 것
        - 대상: Heap 영역의 더 이상 사용되지 않는 Object
        - 메모리 확보 및 효율성 증대
        - 메모리 단편화 방지
        - GC 로 인해 프로그램 성능 저하 우려(Stop-the-world)
    
- 10. 접근 제한자
    - public : 접근에 제한이 없음
    - private : 자기 자신 클래스 내에서만 접근 가능
    - default(package) : 동일한 패키지 내에서만 접근 가능
    - protected : 동일한 패키지 내에서만 접근 가능 + 상속을 이용한 접근 가능
- 11. String vs Char
    - Char 1개의 문자, String은 문자열
    - Char - primitive(== 비교 가능), String - Reference type(equals 사용)
    
- 12. ==과 equals
    - ==
        - 참조 비교로 두 객체가 같은 메모리 공간을 가리키는지 확인 (주소 비교)
    - equals
        - 두 객체의 **내부 값**이 같은지 내용을 비교한다.
        - 기본 타입(Primitive Type)에 대해서는 적용할 수 없다.
        - 객체 비교시 override해서 원하는 방식으로 수정할 수 있다.
- 13. 데이터 타입
    - Value Type
        - **기본 Primitive 타입으로 int, char 등이 있다.**
        - 기본 타입의 크기가 작고 고정적이기 때문에 **메모리 Stack 영역** 에 저장된다.
    - 참조 타입(Reference Type)
        - String과 박싱 타입인 Integer 등이 있다.
        - new 키워드를 이용해 객체를 생성하여 데이터가 생성된 **주소를 참조하는 타입**
        - String과 배열은 일반적인 참조 타입과 달리 new 없이 생성 가능하지만 참조타입이다.
        - 참조 타입은 데이터의 크기가 가변적이고, 동적이므로 **Heap 영역** 에서 관리된다.
        - **데이터는 Heap 영역에서 관리되지만 메모리의 주소값은 Stack 영역에 담긴다.**
    - 더이상 참조하는 변수가 없을 때 GC에 의해 삭제된다.
    
- 14. Call By Value와 Call By Reference
    - Call By Value(값에 의한 호출)
        - 함수 호출 시 인자로 전달되는 **변수의 값을 복사하여 함수의 인자로 전달** 한다.
        - 따라서, **함수 안에서 인자의 값이 변경되어도, 외부의 변수의 값은 변경되지 않는다.**
    - Call by Reference(참조에 의한 호출)
        - **함수 호출 시 인자로 전달되는 변수의 레퍼런스를 전달한다.**
        - 따라서 **함수 안에서 인자의 값이 변경되면, 인자로 전달된 변수의 값도 함께 변경된다.**
    - 자바는 새롭게 지역 변수(다른 주소)를 만들어서 값만 복사하고 할당한다. 따라서 자바는 Call By Value에 해당한다.
- 15. hashcode
    
    **두 객체가 동일한 객체인지 비교할 때 사용하고 heap 영역에 저장된 객체의 메모리 주소를 반환한다.**
